<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>裝備精煉期望值計算器 (五級/四級)</title>
  <style>
    :root{
      --bd:#ddd;
      --text:#111;
      --muted:#666;
      --bg:#fff;
      --bg2:#fafafa;
      --btn:#111;
      --btnbg:#fff;
      --shadow: 0 1px 0 rgba(0,0,0,.03);
      --r:12px;
    }
    *{ box-sizing:border-box; }
    body{
      font-family: system-ui, -apple-system, "Segoe UI", Arial, sans-serif;
      margin: 24px;
      color: var(--text);
      background: var(--bg);
    }
    .wrap{ max-width: 980px; margin: 0 auto; }
    h1{ font-size: 20px; margin: 0 0 12px; }
    .grid{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      align-items: start;
    }
    .card{
      border: 1px solid var(--bd);
      border-radius: var(--r);
      padding: 14px;
      box-shadow: var(--shadow);
      background: var(--bg);
    }
    .row{
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      flex-wrap: wrap;
    }
    label{ font-size: 13px; }
    input[type="number"], select{
      width: 160px;
      padding: 7px 10px;
      border-radius: 10px;
      border: 1px solid var(--bd);
      background: var(--bg);
    }
    input[type="checkbox"], input[type="radio"]{ transform: translateY(1px); }
    .prices{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 12px;
    }
    .prices .p{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      align-items:center;
    }
    .prices .p input{ width: 170px; }
    button{
      padding: 10px 14px;
      border: 1px solid var(--btn);
      background: var(--btnbg);
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover{ background: var(--bg2); }
    textarea{
      width: 100%;
      height: 420px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--bd);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      background: var(--bg);
    }
    .hint{
      color: var(--muted);
      font-size: 12px;
      margin-top: 8px;
      line-height: 1.5;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    @media (max-width: 768px){
      body{ margin: 14px; }
      h1{ font-size: 18px; }
      .grid{ grid-template-columns: 1fr; }
      .card{ padding: 12px; border-radius: 14px; }
      .row{
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      input[type="number"], select{ width: 100%; }
      .prices{ grid-template-columns: 1fr; }
      .prices .p{ width: 100%; }
      .prices .p input{ width: 100%; }
      button{ width: 100%; }
      textarea{ height: 360px; }
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1>裝備精煉期望值計算器(五級/四級)</h1>

  <div class="grid">
    <div class="card">
      <div class="row">
        <label>規則表：</label>
        <select id="ruleset"></select>
      </div>

      <div class="row">
        <label>目標 Target：</label>
        <select id="target"></select>
      </div>

      <div class="row">
        <label>裝備：</label>
        <label><input type="radio" name="gear" value="armor" checked> 防具</label>
        <label><input type="radio" name="gear" value="weapon"> 武器</label>
      </div>

      <div class="row">
        <label><input type="checkbox" id="allowCond" checked> 允許濃縮/高濃縮/高密度</label>
        <label><input type="checkbox" id="allowBless" checked> 允許鐵祝（防爆&防退）</label>
        <label><input type="checkbox" id="forceNoBless"> 強制全程不用鐵祝</label>
      </div>

      <div class="row">
        <label>策略：</label>
        <label><input type="radio" name="mode" value="optimal" checked> 自動最省</label>
        <label><input type="radio" name="mode" value="fixed"> 固定策略</label>
      </div>

      <div class="row">
        <label>固定策略：從 +</label>
        <input type="number" id="fixedFrom" min="0" max="13" value="7" />
        <label>以上用濃縮/高濃縮/高密度</label>
        <label><input type="checkbox" id="fixedUseBless" checked> 固定策略允許鐵祝</label>
      </div>

      <div class="hint" id="ruleHint"></div>
    </div>

    <div class="card">
      <div style="font-weight:700; margin-bottom:8px;">材料實價 (露天)</div>
      <div class="prices" id="prices"></div>

      <div class="row" style="margin-top:12px;">
        <button id="calc">計算（重算）</button>
        <button id="copy">複製結果</button>
      </div>

      <div class="hint">
        * 計算在你的瀏覽器執行（吃使用者電腦資源）。<br/>
        * 同一分頁未關閉時會保留你輸入的價格/選項。
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:16px;">
    <div style="font-weight:700; margin-bottom:8px;">結果</div>
    <textarea id="out" readonly></textarea>
  </div>
</div>

<script>
function fmt(n){ return Math.round(n).toLocaleString("en-US"); }

function applyFail(i, failTo){
  if (failTo === "stay") return i;
  if (failTo === "destroy") return 0;
  if (failTo.startsWith("down:")){
    const k = parseInt(failTo.split(":")[1], 10);
    return Math.max(i - k, 0);
  }
  throw new Error("Unknown fail_to: " + failTo);
}

const RULESETS = [
  {
    id: "lv2_armor_lv5_weapon",
    name: "二級防具 & 五級武器",
    maxTarget: 14,
    pNormal: {
      0:1.00, 1:1.00, 2:1.00,
      3:0.60, 4:0.60, 5:0.40, 6:0.40, 7:0.20, 8:0.20, 9:0.09,
      10:0.08, 11:0.08, 12:0.08, 13:0.08,
    },
    pCond: {
      3:0.90, 4:0.70, 5:0.60, 6:0.60, 7:0.40, 8:0.40, 9:0.20,
      10:0.15, 11:0.15, 12:0.15, 13:0.15,
    },
    blessReq: { 7:1, 8:2, 9:3, 10:4, 11:4, 12:9, 13:15 },
    protectFailTo: "stay",
    failRuleNormal: (i)=> (i <= 9) ? "down:3" : "destroy",
    failRuleCond:   (i)=> (i <= 9) ? "down:1" : "destroy",
    materialFor: (gear, i, mode)=>{
      if (gear === "armor"){
        if (i <= 9){
          return (mode === "normal") ? "乙太鋁" : "濃縮乙太鋁";
        } else {
          return (mode === "normal") ? "乙太鈣礦石" : "高濃縮乙太鋁";
        }
      } else {
        if (i <= 9){
          return (mode === "normal") ? "乙太神之金屬" : "濃縮乙太神之金屬";
        } else {
          return (mode === "normal") ? "乙太鈽鐳礦石" : "高濃縮乙太神之金屬";
        }
      }
    },
    priceKeys: [
      "乙太鋁","濃縮乙太鋁","高濃縮乙太鋁","乙太鈣礦石",
      "乙太神之金屬","濃縮乙太神之金屬","高濃縮乙太神之金屬","乙太鈽鐳礦石",
      "鐵匠的祝福"
    ],
    defaultPrices: {
      "乙太鋁": 70000,
      "濃縮乙太鋁": 990000,
      "高濃縮乙太鋁": 1200000,
      "乙太鈣礦石": 170000,
      "乙太神之金屬": 85000,
      "濃縮乙太神之金屬": 920000,
      "高濃縮乙太神之金屬": 1000000,
      "乙太鈽鐳礦石": 170000,
      "鐵匠的祝福": 3700000,
    },
    hintHtml: `
      <div>規則摘要：</div>
      <div class="mono">- 3~9：normal 失敗 -3；濃縮 失敗 -1</div>
      <div class="mono">- 10~13：失敗 destroy（裝備消失）</div>
      <div class="mono">- 鐵祝：失敗 stay（防爆&防退）</div>
    `
  },

  {
    id: "lv1_armor_lv4_weapon",
    name: "一級防具 & 四級武器（鋁 / 神之金屬）",
    maxTarget: 14,
    pNormal: {
      0:1.00, 1:1.00, 2:1.00, 3:1.00,
      4:0.60, 5:0.40, 6:0.40, 7:0.20, 8:0.20, 9:0.09,
      10:0.08, 11:0.08, 12:0.08, 13:0.08,
    },
    pCond: {
      4:0.90, 5:0.70, 6:0.70, 7:0.40, 8:0.40, 9:0.20,
      10:0.08, 11:0.08, 12:0.08, 13:0.08,  // +10~+13：你說成功率相同
    },
    blessReq: { 7:1, 8:2, 9:3, 10:4, 11:4, 12:9, 13:15 },
    protectFailTo: "stay",
    failRuleNormal: (i)=>{
      if (i <= 3) return "stay";
      return "destroy"; // 4~13：無鐵祝會爆
    },
    failRuleCond: (i)=>{
      if (i >= 4 && i <= 6) return "destroy";
      if (i >= 7 && i <= 13) return "down:1";
      return "destroy";
    },
    materialFor: (gear, i, mode)=>{
      const in1013 = (i >= 10);
      if (gear === "armor"){
        if (!in1013){
          if (mode === "normal") return "鋁";
          if (i <= 6) return "濃縮鋁";
          return "高濃縮鋁"; // 7~9
        } else {
          if (mode === "normal") return "鈣礦石";
          return "高密度鈣礦石"; // treated as "high"
        }
      } else {
        if (!in1013){
          if (mode === "normal") return "神之金屬";
          if (i <= 6) return "濃縮神之金屬";
          return "高濃縮神之金屬"; // 7~9
        } else {
          if (mode === "normal") return "鈽鐳礦石";
          return "高密度鈽鐳礦石"; // treated as "high"
        }
      }
    },
    priceKeys: [
      "鋁","濃縮鋁","高濃縮鋁",
      "神之金屬","濃縮神之金屬","高濃縮神之金屬",
      "鈣礦石","高密度鈣礦石",
      "鈽鐳礦石","高密度鈽鐳礦石",
      "鐵匠的祝福"
    ],
    defaultPrices: {
      "鋁": 10000,
      "神之金屬": 22000,
      "濃縮鋁": 850000,
      "高濃縮鋁": 960000,
      "濃縮神之金屬": 785000,
      "高濃縮神之金屬": 1000000,
      "鈣礦石": 9000,
      "高密度鈣礦石": 1100000,
      "鈽鐳礦石": 8000,
      "高密度鈽鐳礦石": 900000,
      "鐵匠的祝福": 3700000,
    },
    hintHtml: `
      <div>規則摘要：</div>
      <div class="mono">- 0~3：100%</div>
      <div class="mono">- 4~6：normal/濃縮失敗 destroy（不可祝福）</div>
      <div class="mono">- 7~9：normal/濃縮失敗 destroy；高濃縮失敗 -1（可祝福）</div>
      <div class="mono">- 10~13：normal（鈣/鈽鐳）與高密度成功率相同；</div>
      <div class="mono">　　　　無鐵祝時 normal 會爆（destroy），高密度失敗 -1；有鐵祝失敗 stay</div>
    `
  }
];

function buildActions(rs, gear, prices, target, opts){
  const { allowCondensed, allowBless, forceNoBless } = opts;
  const blessPrice = prices["鐵匠的祝福"] ?? 0;
  const allowProt = allowBless && !forceNoBless;

  const actionsByLevel = {};
  for (let i=0; i<target; i++){
    const acts = [];

    const psN = rs.pNormal[i];
    const matN = rs.materialFor(gear, i, "normal");
    const costN = prices[matN] ?? 0;
    acts.push({ name:`normal(${matN})`, ps:psN, failTo:rs.failRuleNormal(i), cost:costN });

    if (allowProt && rs.blessReq[i] != null){
      const qty = rs.blessReq[i];
      acts.push({ name:`normal+protect(x${qty})`, ps:psN, failTo:rs.protectFailTo, cost:costN + qty*blessPrice });
    }

    if (allowCondensed && rs.pCond[i] != null){
      const psC = rs.pCond[i];
      let modeName = "condensed";
      if (rs.id === "lv1_armor_lv4_weapon"){
        modeName = (i >= 7) ? "high" : "condensed";
      } else {
        modeName = (i >= 10) ? "high" : "condensed";
      }

      const matC = rs.materialFor(gear, i, modeName);
      const costC = prices[matC] ?? 0;

      acts.push({ name:`${modeName}(${matC})`, ps:psC, failTo:rs.failRuleCond(i), cost:costC });

      if (allowProt && rs.blessReq[i] != null){
        const qty = rs.blessReq[i];
        acts.push({ name:`${modeName}+protect(x${qty})`, ps:psC, failTo:rs.protectFailTo, cost:costC + qty*blessPrice });
      }
    }

    actionsByLevel[i] = acts;
  }
  return actionsByLevel;
}

function expectedCostOptimal(actionsByLevel, target){
  const E = new Array(target+1).fill(0);
  const best = new Array(target+1).fill("");
  E[target] = 0;

  const tol = 1e-10;
  const maxIter = 200000;

  for (let iter=0; iter<maxIter; iter++){
    let maxDiff = 0;
    const Eold = E.slice();
    const bestOld = best.slice();

    for (let i=0; i<target; i++){
      let bestVal = Infinity;
      let bestName = "";
      const acts = actionsByLevel[i];

      for (const a of acts){
        const ps = a.ps;
        const pf = 1 - ps;
        const succ = Math.min(i+1, target);
        const fail = applyFail(i, a.failTo);
        const val = a.cost + ps*Eold[succ] + pf*Eold[fail];
        if (val < bestVal){
          bestVal = val;
          bestName = a.name;
        }
      }
      E[i] = bestVal;
      best[i] = bestName;
      maxDiff = Math.max(maxDiff, Math.abs(E[i] - Eold[i]));
    }

    let samePolicy = true;
    for (let i=0; i<target; i++){
      if (best[i] !== bestOld[i]) { samePolicy = false; break; }
    }
    if (maxDiff < tol && samePolicy) break;
  }

  return { E, best };
}

function expectedCostFixed(actionsByLevel, chosen, target){
  const A = Array.from({length: target}, () => new Array(target).fill(0));
  const b = new Array(target).fill(0);

  for (let i=0; i<target; i++){
    const acts = {};
    for (const a of actionsByLevel[i]) acts[a.name] = a;

    const name = chosen[i];
    const a = acts[name];
    if (!a) throw new Error(`固定策略在 +${i} 選的 action 不存在：${name}`);

    const ps = a.ps;
    const pf = 1 - ps;
    const succ = Math.min(i+1, target);
    const fail = applyFail(i, a.failTo);

    A[i][i] = 1;
    b[i] = a.cost;

    if (succ < target) A[i][succ] -= ps;
    if (fail < target) A[i][fail] -= pf;
  }

  const M = A.map((row, i) => row.concat([b[i]]));

  for (let col=0; col<target; col++){
    let pivot = col;
    for (let r=col; r<target; r++){
      if (Math.abs(M[r][col]) > Math.abs(M[pivot][col])) pivot = r;
    }
    if (Math.abs(M[pivot][col]) < 1e-14) throw new Error("矩陣不可解（策略可能導致）");
    if (pivot !== col){
      const tmp = M[pivot]; M[pivot] = M[col]; M[col] = tmp;
    }
    const div = M[col][col];
    for (let c=col; c<=target; c++) M[col][c] /= div;

    for (let r=0; r<target; r++){
      if (r === col) continue;
      const factor = M[r][col];
      if (factor === 0) continue;
      for (let c=col; c<=target; c++){
        M[r][c] -= factor * M[col][c];
      }
    }
  }

  const E = new Array(target+1).fill(0);
  for (let i=0; i<target; i++) E[i] = M[i][target];
  E[target] = 0;
  return E;
}

function buildFixedChoice(actionsByLevel, target, opts, fixedFrom, fixedUseBless){
  const { allowCondensed, allowBless, forceNoBless } = opts;
  const chosen = {};

  for (let i=0; i<target; i++){
    const available = actionsByLevel[i].map(a => a.name);
    const wantBless = fixedUseBless && allowBless && !forceNoBless;
    const canBless = wantBless && available.some(n => n.includes("+protect"));

    const preferHighOrCond = allowCondensed && (i >= fixedFrom) && available.some(n => n.startsWith("condensed") || n.startsWith("high"));

    if (preferHighOrCond){
      let pick = null;
      if (available.some(n=>n.startsWith("high"))){
        if (canBless) pick = available.find(n => n.startsWith("high+protect")) || null;
        if (!pick) pick = available.find(n => n.startsWith("high(")) || null;
      } else {
        if (canBless) pick = available.find(n => n.startsWith("condensed+protect")) || null;
        if (!pick) pick = available.find(n => n.startsWith("condensed(")) || null;
      }
      if (!pick){
        if (canBless) pick = available.find(n => n.startsWith("normal+protect")) || null;
        if (!pick) pick = available.find(n => n.startsWith("normal(")) || null;
      }
      chosen[i] = pick;
    } else {
      let pick = null;
      if (canBless) pick = available.find(n => n.startsWith("normal+protect")) || null;
      if (!pick) pick = available.find(n => n.startsWith("normal(")) || null;
      chosen[i] = pick;
    }

    if (!chosen[i]) throw new Error(`+${i} 沒有可用的 action（設定太嚴格？）`);
  }
  return chosen;
}

function computeAll(rs, gear, prices, opts, mode, fixedFrom, fixedUseBless, target){
  const actionsT = buildActions(rs, gear, prices, target, opts);

  let E_to_T, best;
  if (mode === "fixed"){
    const chosen = buildFixedChoice(actionsT, target, opts, fixedFrom, fixedUseBless);
    E_to_T = expectedCostFixed(actionsT, chosen, target);
    best = new Array(target+1).fill("");
    for (let i=0; i<target; i++) best[i] = chosen[i];
  } else {
    const res = expectedCostOptimal(actionsT, target);
    E_to_T = res.E;
    best = res.best;
  }

  const E_0_to_k = [0];
  for (let k=1; k<=target; k++){
    const actionsK = buildActions(rs, gear, prices, k, opts);
    if (mode === "fixed"){
      const chosenK = buildFixedChoice(actionsK, k, opts, fixedFrom, fixedUseBless);
      const Ek = expectedCostFixed(actionsK, chosenK, k);
      E_0_to_k.push(Ek[0]);
    } else {
      const resK = expectedCostOptimal(actionsK, k);
      E_0_to_k.push(resK.E[0]);
    }
  }

  const segCosts = [];
  for (let i=0; i<target; i++) segCosts.push(E_to_T[i] - E_to_T[i+1]);

  let firstCond=null, firstHigh=null, firstBless=null;
  if (mode === "optimal"){
    for (let i=0; i<target; i++){
      const s = best[i] || "";
      if (firstCond === null && s.startsWith("condensed")) firstCond = i;
      if (firstHigh === null && s.startsWith("high")) firstHigh = i;
      if (firstBless === null && s.includes("+protect")) firstBless = i;
    }
  }

  return { E_to_T, best, E_0_to_k, segCosts, firstCond, firstHigh, firstBless };
}

/** ===== UI ===== **/
const SESSION_KEY = "refine_ev_session_rulesets_v3";
let currentRule = RULESETS[0];
function $(id){ return document.getElementById(id); }
function getGear(){ return [...document.querySelectorAll('input[name="gear"]')].find(r => r.checked).value; }
function getMode(){ return [...document.querySelectorAll('input[name="mode"]')].find(r => r.checked).value; }

function buildRulesetOptions(){
  const sel = $("ruleset");
  sel.innerHTML = "";
  for (const rs of RULESETS){
    const opt = document.createElement("option");
    opt.value = rs.id;
    opt.textContent = rs.name;
    sel.appendChild(opt);
  }
}

function buildTargetOptions(maxT){
  const sel = $("target");
  const prev = sel.value;
  sel.innerHTML = "";
  for (let t=1; t<=maxT; t++){
    const opt = document.createElement("option");
    opt.value = String(t);
    opt.textContent = `+${t}`;
    sel.appendChild(opt);
  }
  if (prev && Number(prev) <= maxT) sel.value = prev;
  else sel.value = String(Math.min(14, maxT));
}

function buildPriceInputs(rs, keepExisting=true){
  const box = $("prices");
  box.innerHTML = "";
  const state = keepExisting ? snapshotFormState(false) : null;

  for (const k of rs.priceKeys){
    const div = document.createElement("div");
    div.className = "p";
    const v = (state && state.prices && state.prices[k] != null) ? state.prices[k] : (rs.defaultPrices[k] ?? 0);
    div.innerHTML = `<label>${k}</label><input type="number" id="p_${k}" value="${v}" />`;
    box.appendChild(div);
  }
}

function readPrices(rs){
  const prices = {};
  for (const k of rs.priceKeys){
    const el = document.getElementById("p_" + k);
    const v = Number(el.value);
    if (!Number.isFinite(v) || v < 0) throw new Error(`價格不正確：${k}`);
    prices[k] = v;
  }
  return prices;
}

function snapshotFormState(write=true){
  const rsId = $("ruleset").value;
  const state = {
    ruleset: rsId,
    target: $("target").value,
    gear: getGear(),
    mode: getMode(),
    allowCond: $("allowCond").checked,
    allowBless: $("allowBless").checked,
    forceNoBless: $("forceNoBless").checked,
    fixedFrom: $("fixedFrom").value,
    fixedUseBless: $("fixedUseBless").checked,
    prices: {}
  };
  const rs = RULESETS.find(r=>r.id===rsId) || currentRule;
  for (const k of rs.priceKeys){
    const el = document.getElementById("p_" + k);
    if (el) state.prices[k] = el.value;
  }
  if (write) sessionStorage.setItem(SESSION_KEY, JSON.stringify(state));
  return state;
}

function restoreFormState(){
  const raw = sessionStorage.getItem(SESSION_KEY);
  if (!raw) return false;
  try{
    const state = JSON.parse(raw);
    if (!state || !state.ruleset) return false;

    $("ruleset").value = state.ruleset;
    if (typeof state.allowCond === "boolean") $("allowCond").checked = state.allowCond;
    if (typeof state.allowBless === "boolean") $("allowBless").checked = state.allowBless;
    if (typeof state.forceNoBless === "boolean") $("forceNoBless").checked = state.forceNoBless;

    if (state.gear){
      const g = [...document.querySelectorAll('input[name="gear"]')].find(r => r.value === state.gear);
      if (g) g.checked = true;
    }
    if (state.mode){
      const m = [...document.querySelectorAll('input[name="mode"]')].find(r => r.value === state.mode);
      if (m) m.checked = true;
    }
    if (state.fixedFrom != null) $("fixedFrom").value = state.fixedFrom;
    if (typeof state.fixedUseBless === "boolean") $("fixedUseBless").checked = state.fixedUseBless;

    const rs = RULESETS.find(r=>r.id===state.ruleset) || RULESETS[0];
    currentRule = rs;
    $("ruleHint").innerHTML = rs.hintHtml;

    buildTargetOptions(rs.maxTarget);
    if (state.target && Number(state.target) <= rs.maxTarget) $("target").value = state.target;

    buildPriceInputs(rs, false);
    if (state.prices){
      for (const k of rs.priceKeys){
        if (state.prices[k] != null){
          const el = document.getElementById("p_" + k);
          if (el) el.value = state.prices[k];
        }
      }
    }
    return true;
  } catch { return false; }
}

function bindAutosave(){
  document.addEventListener("input", (e) => {
    const id = e.target && e.target.id;
    if (!id) return;
    if (id.startsWith("p_") || id === "fixedFrom") snapshotFormState(true);
  });
  document.addEventListener("change", () => snapshotFormState(true));
}

function render(){
  const rs = RULESETS.find(r=>r.id===$("ruleset").value) || RULESETS[0];
  currentRule = rs;

  const target = Number($("target").value);
  const gear = getGear();
  const mode = getMode();
  const prices = readPrices(rs);

  const opts = {
    allowCondensed: $("allowCond").checked,
    allowBless: $("allowBless").checked,
    forceNoBless: $("forceNoBless").checked,
  };

  const fixedFrom = Number($("fixedFrom").value);
  const fixedUseBless = $("fixedUseBless").checked;

  const res = computeAll(rs, gear, prices, opts, mode, fixedFrom, fixedUseBless, target);

  const lines = [];
  lines.push(`=== 裝備精煉期望值計算（${rs.name}；目標 +${target}）===`);
  lines.push(`裝備類型：${gear === "armor" ? "防具" : "武器"}`);
  lines.push(`策略模式：${mode === "optimal" ? "自動最省" : "固定策略"}`);
  if (mode === "fixed"){
    lines.push(`  固定策略：+${fixedFrom} 以上用濃縮/高濃縮/高密度；鐵祝=${(fixedUseBless && opts.allowBless && !opts.forceNoBless) ? "開" : "關"}`);
  }
  lines.push(`濃縮材料：${opts.allowCondensed ? "開" : "關"}`);
  lines.push(`鐵祝：${(opts.allowBless && !opts.forceNoBless) ? "開" : "關"}（強制不用鐵祝=${opts.forceNoBless ? "是" : "否"}）`);
  lines.push(`鐵祝效果：失敗 stay（防爆&防退）`);
  lines.push("");

  lines.push("---- 建議門檻（依『自動最省』結果）----");
  if (mode === "fixed"){
    lines.push("（固定策略模式：門檻自定，不提供自動建議）");
  } else {
    if (!opts.allowCondensed){
      lines.push("濃縮材料已禁用：不提供濃縮/高濃縮/高密度建議");
    } else {
      lines.push(res.firstCond == null ? "濃縮建議：未使用 condensed" : `濃縮建議：從 +${res.firstCond} 開始用 condensed`);
      lines.push(res.firstHigh == null ? "高階材料建議：未使用 high" : `高階材料建議：從 +${res.firstHigh} 開始用 high`);
    }
    if (opts.allowBless && !opts.forceNoBless){
      lines.push(res.firstBless == null ? "鐵祝建議：未使用鐵祝" : `鐵祝建議：從 +${res.firstBless} 起開始使用鐵祝`);
    } else {
      lines.push("鐵祝已禁用：不提供鐵祝建議");
    }
  }
  lines.push("");

  lines.push(`---- 從 +i 到 +${target} 的期望成本 ----`);
  for (let i=0; i<=target; i++){
    const v = res.E_to_T[i];
    if (i === target){
      lines.push(`+${String(i).padStart(2," ")} -> +${target} : ${fmt(v)}`);
    } else {
      lines.push(`+${String(i).padStart(2," ")} -> +${target} : ${fmt(v)}   | choice: ${res.best[i]}`);
    }
  }
  lines.push("");

  lines.push(`---- 區間成本（以目標 +${target} 的邊際期望）----`);
  for (let i=0; i<target; i++){
    lines.push(`+${String(i).padStart(2," ")} -> +${String(i+1).padStart(2," ")} : ${fmt(res.segCosts[i])}   | choice at +${i}: ${res.best[i]}`);
  }
  lines.push("");

  lines.push(`---- 從 +0 到 +k 的期望成本（k=0..${target}）----`);
  for (let k=0; k<=target; k++){
    lines.push(`+0 -> +${String(k).padStart(2," ")} : ${fmt(res.E_0_to_k[k])}`);
  }

  $("out").value = lines.join("\n");
}

/** ===== Init ===== **/
buildRulesetOptions();
buildTargetOptions(RULESETS[0].maxTarget);
$("ruleHint").innerHTML = RULESETS[0].hintHtml;
buildPriceInputs(RULESETS[0], false);

const restored = restoreFormState();
if (!restored){
  $("ruleset").value = RULESETS[0].id;
  currentRule = RULESETS[0];
  $("ruleHint").innerHTML = currentRule.hintHtml;
  buildTargetOptions(currentRule.maxTarget);
  buildPriceInputs(currentRule, false);
}

bindAutosave();
render();

$("ruleset").addEventListener("change", ()=>{
  const rs = RULESETS.find(r=>r.id===$("ruleset").value) || RULESETS[0];
  currentRule = rs;
  $("ruleHint").innerHTML = rs.hintHtml;
  buildTargetOptions(rs.maxTarget);
  buildPriceInputs(rs, true);
  snapshotFormState(true);
  render();
});

$("calc").addEventListener("click", () => {
  try { render(); snapshotFormState(true); } catch(e){ alert(e.message || String(e)); }
});

$("copy").addEventListener("click", async () => {
  const text = $("out").value;
  try {
    await navigator.clipboard.writeText(text);
    alert("已複製到剪貼簿");
  } catch {
    $("out").select();
    document.execCommand("copy");
    alert("已複製到剪貼簿（fallback）");
  }
});
</script>
</body>
</html>
